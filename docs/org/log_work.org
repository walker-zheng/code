# -*- org -*-
# -*- coding:utf-8 -*-

# Time-stamp: <2016-07-23 14:25:19 (mykulou@gmail.com)>
#+SETUPFILE: theme-bigblow-local.setup

* 工作日志
** 7月
*** 2013-07-02
    - 安装配置环境： opencv + vs2008 + cmake
    - 简单测试可用
    - 查找opencv相关资料
*** 2013-07-03
    - 看资料 文档 sample
    - opencv模块结构、数据结构
    - 图像的基本读写操作
      
*** 2013-07-04、2013-07-05
    - sift算法的基本思路，用法，及方法和接口的参数等
    - 搜索引擎简单培训（历史、分类、模块等）、opencv简单培训（应用和sift）
*** 2013-07-08
    - 周报例会
    - sift的简单demo
*** 2013-07-09
    - demo处理图片，寻找合适response，以便精简keypoint
*** 2013-07-10
    - 了解和编译opencv的java库，检查接口扩充后JNI是否能正常使用；了解
      JNI机制
*** 2013-07-11、2013-07-12
    - 查找JNI接口生成代码的在py脚本中的位置，了解py调试方法(pdb)
*** 2013-07-15
    - opencv文档阅读；稳定性测试；周报等
** 8月
*** 2013-08-12
    - 调试添加contour到sift算法中，以mask形式过滤keypoint，但调试发现
      时2.4.5的bug（坐标变化了）；合入2.4.6的代码，并编译；输出轮廓相
      应的mask生成接口;
    - 修改img-proc对图片最外一圈的判断，相应不用去白边
    - todo：测试轮廓mask接口效果和性能提升等
*** 2013-08-13
    - 在linux下，用轮廓的sift的生成一片图片，对比效果，加轮廓后
      会对关键点有部分减少，特别是对复杂背景的图片
    - 批量处理图片去白边和改大小的工具和脚本基本稳定，有精简下config配
      置的结构，由proc.sh调用不同的config和img-proc，以处理不同目录不
      同要求的批处理
*** 2013-08-14
    - 添加了一个用于统计性能的脚本perf.sh，可以看到处理的性能统计，目
      前一般是1w张图要7-8m，每秒20多张；
    - 协助进行去白边处理，准备不同要求的图片
*** 2013-08-15
    - 查找mfc和bcg相关资料，安装测试bcg，以便之后熟悉和开发win下桌面应
      用
    - 协助输出图片处理，参与一号店测试各种测试
*** 2013-08-26
    - 添加轮廓处理到去白边程序中，并批量测试，效果不错，不仅能去logo，也能去掉其他
      部分；但对于有阴影的可能会与logo相连，均衡化可能能够解决此问题。
    - 之前做kmeans的部分代码，让马子平修改并合入到去logo程序中。
*** 2013-08-27
    - 添加自适应阈值化处理，对于阴影有部分效果；输出轮廓去logo接口，与
      之前马子平的物体检测去logo的方法和并，提高效率和准确度；使用mask面
      积判断是直接修复，还是使用物体检测法修复；去logo使用独立接口，与
      去白边无关；
    - 计划：
       - 问题：kmeans在linux和win32上不稳定，需要调试；或者要用blocksize
         较大的自适应阈值处理
       - 2013-08-28：测试和调整去logo无问题
       - 2013-08-29：测试特征信息写入文件的性能，及脚本调整，考虑性能
         提升
       
* 问题
** 编译opencv
   - cmake配置生成sln，再编译debug、release版本，vs2008/install目录bin、
     include、lib
   - bin添加到环境变量，include和lib添加到 解决方案->vc++目录；属性c++
     中添加include目录，连接器->输入中添加依赖库
** 编译opencv的java库
   1. 预安装：ant、python、jdk（to-be-build里面有java）
   2. cmake -DBUILD_SHARED_LIBS=OFF
   3. make -j8
   4. 生成bin/opencv-245.jar和lib/libopencv_java245.so
   5. 编译生成jni相关的native代码；cpp里面有java包路径对应的方法
      #+begin_src cpp
JNIEXPORT void JNICALL Java_org_opencv_samples_facedetect_DetectionBasedTracker_nativeStart
  (JNIEnv *, jclass, jlong);
      #+end_src
     而java中使用则要导入jar库，调用用前要loadLibrary
     
** imread失败
   - debug和release库不能混用（分别对应）
** 未定义
   - 是否是namespace问题

** jni编译
   - jni一般编译
     #+begin_src cpp
	# java file
     javac Main.java		# >> .class
     javah -jni HelloWorld	# >> .h
	# implement method in cpp
	# vs tools x64 cmd/vcvarsall.bat x64
	# >> dll exp lib
	cl -I"C:\Program Files\Java\jdk1.7.0_25\include" -I"C:\Program Files\Java\jdk1.7.0_25\include\win32" -LD HelloWorld.cpp -FeHelloWorldImp.dll
	java Main
     #+end_src
   - opencv中java接口添加
     - generator的gen_java.py中，添加jni
     - 或在generator/src/*.cpp中修改，但要在if 0注释中添加声明(用于解
       析)；cmake后对比相应的junk文件，如果不一致，则检查修改
** vs问题
*** vc++编辑功能被锁定
    - 编辑Microsoft.Cpp.Win32.user属性表，添加的部分去掉
*** win32/x64冲突
    - 安装x64编译器
    - 配置管理器添加x64，不复制win32（自动添加宏和相应配置变量为x64）
    - 项目属性中，对x64的配置include、lib、目标计算机等位x64
    - 添加自己要用的库（编译的要是相应的平台库x64）
    - Now the fix ther you see suggested everywhere is to change the
      project setting for the target machine, unfortunatly this
      already gets changed with the creation of a new x64 platform:
      MachineX64 (/MACHINE:X64)
    - A few information that might be relevant:
      - I'm linking the runtime library statically (/MTd).
      - I'm using Visual Studio Ultimate (being a student ftw!).
      - I'm running Window 7 x64.
      - The include and library paths get updated correctly to the location of the x64 libraries.
      - Cleaning the solution and rebuilding does help.
    - In fact the problem is that VS for some reason doesn't update
      the library paths.
*** LINK : fatal error LNK1181
    - 不能连接lib或dll，检查是否存在，是否添加到VC++库目录，是否添加依
      赖项
*** 0xc0150002应用程序无法启动
    - 
* tips总结
** c++
*** 文件遍历（第二种更简单）
    #+begin_src cpp
    find(char * lpPath)  
    {  
    　　char szFind[MAX_PATH];  
    　　WIN32_FIND_DATA FindFileData;  
    　　strcpy(szFind,lpPath);  
    　　strcat(szFind,"*.*");  
    　　HANDLE hFind=::FindFirstFile(szFind,&FindFileData);  
    　　if(INVALID_HANDLE_VALUE == hFind)　　return;  
    　　while(TRUE)  
    　　{  
    　　　　if(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)  
    　　　　{  
    　　　　　　if(FindFileData.cFileName[0]!='.')  
    　　　　　　{  
    　　　　　　　　strcpy(szFile,lpPath);  
    　　　　　　　　strcat(szFile,"");  
    　　　　　　　　strcat(szFile,FindFileData.cFileName);  
    　　　　　　　　find(szFile);  
    　　　　　　}  
    　　　　}  
    　　　　else  
    　　　　{  
    　　　　　　cout << FindFileData.cFileName;  
    　　　　}  
    　　　　if(!FindNextFile(hFind,&FindFileData))　　break;  
    　　}  
    　　FindClose(hFind);  
    }
 void RecursiveFindFile(CString& strPath)
{
   CFileFind ff;
   BOOL bFind = ff.FindFile(strPath + "\*.*");
 
   while(bFind)
   {
      bFind = ff.FindNextFile();
      if (ff.IsDots() || ff.IsSystem() || ff.IsHidden())
         continue;
       
      if (ff.IsDirectory())
      {
         RecursiveFindFile(ff.GetFilePath());
      }
      else
      {
         CString strFileName = ff.GetFileName();
         AfxMessageBox(strFileName);
      }
   }
}
    #+end_src
**** CFileFind类
    - GetFilePath()、GetFileName()、GetFileTitle()、GetFileURL()等函数必须
      要在FindNextFile()之后执行才能成功
*** String CString char* wchar_t* 
    #+begin_src cpp
//string 转 CString
CString.format(”%s”, string.c_str());
//char 转 CString
CString.format(”%s”, char*);
//char 转 string
string s(char *);
//string 转 char *
char *p = string.c_str();
//CString 转 string
string s(CString.GetBuffer());
//char转换成wchar
MultiByteToWideChar(CP_ACP,   0,   pFilePathName,   nLen,   lpszFile,   nwLen);
//wchar转换成char
WideCharToMultiByte(CP_ACP,   0,   lpszFile,   nLen,   pFilePathName,   2*nLen,   NULL,   NULL);
    #+end_src

*** 字符串分割
    1. strtok
       - char *strtok(char *str, const char *delim);
    2. STL：find + substr
    3. boost：split(正则)
** python
*** 调试，pdb
    - 先要扫描进代码，才能识别字段、方法，所以先在__main__处断点
** java 
   - java docs&srcs
	1.下载jdk
	网址如下http://www.oracle.com/technetwork/java/index.html
	2.配置环境变量
   		1.我的电脑->属性->高级->环境变量->系统变量中添加以下环境变量：
   		2.JAVA_HOME值为【D:\Program Files\Java\jdk1.6.0_18】（你安装JDK的目录）
   		3.CLASSPATH值为：【.;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\bin;】（固定的）
   		4.Path:  在开始追加 【%JAVA_HOME%\bin;】
	3.eclipse中配置doc以及source
	   Eclipse有直接查看java文档和类库源码的功能，不过得手工添加才行，下面对如何在Eclipse中添加java文档和类库源码进行总结。
		1. Window->Pereferences->Java->InstalledJREs，此时右边窗口会显示已经加载的jre。
		2. 选中要设置的jre版本，单击"Edit"，弹出JRE编辑窗口
		3. 添加javadoc：将JREsystem libraries下的所有包选中，单击右边的“JavadocLocation”按钮，弹出javadoc设置窗口。选择“JavadocURL”单选框，单击“Browse”按钮，选中docs/api目录，然后点击“OK”
		4. 添加source：将JREsystem libraries下的所有包选中，单击右边的“SourceAttachment”按钮，弹出sourceattachment configuration窗口。单击“ExternalFile”按钮，选中java安装目录中的src.zip文件，然后点击“OK”
		5. 后面就一路OK、确定就行了。
     在添加好了javadoc与source后，在eclipse中，使用快捷键"Shift+F2"，
     可快速调出选中类的api文档；使用快捷建F3（或在类上点击右键，现在查
     看声明），可打开类的源文件。
     
     
* [[file:index.html][wiki]]
